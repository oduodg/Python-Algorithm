# 09 스택, 큐
스택

- LIFO(Last-In-First-Out) 후입선출
- 잔뜩 쌓아둔 접시 → 마지막에 쌓은 접시를 제일 먼저 꺼내게 됨
- `push()` : 요소를 컬렉션에 추가한다.
- `pop()` : 아직 제거되지 않은 가장 최근에 삽입된 요소를 제거한다.
- 파이썬 리스트는 스택 연산인 푸시와 팝이 O(1)에 동작함.
- 스택 버퍼 오버플로(Stack Buffer Overflow): 꽉 찬 스택에 요소를 삽입하고자 할 때 스택에 요소가 넘쳐서 에러가 발생하는 것

큐

- FIFO(First-In-First-Out) 선입선출
- 줄을 선 사람들 → 가장 먼저 줄을 선 사람이 먼저 입장

파이썬의 리스트

- 스택, 큐의 모든 연산을 지원
- 리스트는 동적 배열로 구현되어 있어 큐의 연산을 수행하기에는 효율적x → 큐를 위해서는 데크(Deque)라는 별도의 자료형을 사용해야 좋은 성능을 낼 수 있음.

> 연결 리스트를 이용한 스택 ADT 구현
> 

```python
# 연결 리스트를 담을 Node 클래스 정의
class Node:
		def __init__(self, item, next):
				self.item = item # 노드의 값은 item
				self.next = next # 다음 노드를 가리키는 포인터는 next

# 스택의 연산 push(), pop()을 담은 Stack 클래스 정의
class Stack:
    def __init__(self):
        self.last = None
    
		# push()는 연결 리스트에 요소를 추가하면서 가장 마지막 값을 next로 지정하고, 포인터인 last는 가장 마지막으로 이동시킨다.
    def push(self, item):
        self.last = Node(item, self.last)
    
		# pop()은 가장 마지막 아이템을 끄집어내고 last 포인터를 한 칸 앞으로 전진 시킨다. 즉 이전에 추가된 값을 가리키게 한다.
    def pop(self):
        item = self.last.item
        self.last = self.last.next
        return item

stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
stack.push(4)
stack.push(5)

for _ in range(5):
    print(stack.pop())

''' 결과
5
4
3
2
1
'''
```

---

## 20 [유효한 괄호](https://leetcode.com/problems/valid-parentheses/)

괄호로 된 입력값이 올바른지 판별하라.

### 풀이 1. 스택 일치 여부 판별

(, [, { 는 스택에 푸시하고, ),],} 를 만날 때 스택에서 팝한 결과가 매핀 테이블 결과와 매칭되는지 확인하면 된다. 먼저 매핑 테이블을 만들어 놓고 테이블에 존재하지 않으면 무조건 푸시하고, 팝했을 때 결과가 일치하지 않으면 False를 리턴한다.

---

## 21 [중복 문자 제거](https://leetcode.com/problems/remove-duplicate-letters/)

중복된 문자를 제외하고 사전식 순서로 나열하라.

### 풀이 1. 재귀를 이용한 분리

### 풀이 2. 스택을 이용한 문자 제거

- `collections.Counter()`

---

## 22 [일일 온도](https://leetcode.com/problems/daily-temperatures/)

매일의 화씨 온도 리스트 T를 입력받아서, 더 따뜻한 날씨를 위해서는 며칠을 더 기다려야 하는지를 출력하라.

### 풀이 1. 스택 값 비교

현재의 인덱스를 계속 스택에 쌓아두다가, 이전보다 상승하는 지점에서 현재 온도와 스택에 쌓아둔 인덱스 지점의 온도 차이를 비교해서, 더 높다면 다음과 같이 스택의 값을 팝으로 꺼내고 현재 인덱스와 스택에 쌓아둔 인덱스의 차이를 정답으로 처리한다.

---

## 23 [큐를 이용한 스택 구현](https://leetcode.com/problems/implement-stack-using-queues/)

### 풀이 1. push() 할 때 큐를 이용해 재정렬

문제의 의도에 맞게 큐의 FIFO에 해당하는 연산만 사용해서 구현해본다. 먼저, 큐의 선언은 데크로 한다.

push()할 때, 요소를 삽입한 후에 방금 삽입한 요소를 맨 앞에 두는 상태로 전체를 재정렬한다. 이렇게 하면 큐에서 맨 앞 요소를 끄집어낼 때 스택처럼 가장 먼저 삽입한 요소가 나오게 될 것이다.

---

## 24 [스택을 이용한 큐 구현](https://leetcode.com/problems/implement-queue-using-stacks/)

### 풀이 1. 스택 2개 사용

스택으로 구현하기 때문에 pop()을 이용하면 맨 뒤의 아이템을 끄집어낼 수 밖에 없다. 따라서 이 문제를 스택의 연산만을 사용해서 풀기 위해서는 2개의 스택이 필요하다. 특히 pop()과 peek()는 결국 같은 데이터를 끄집어낸다는 점에 착안해, 이번에는 pop()을 할 때 peek()를 호출하고 여기에 재입력하는 알고리즘을 구현했다.

```python
if not self.output:
		while self.input:
				self.output.append(self.input.pop())
```

이렇게 구현해도 output의 값이 모두 팝되기 전까지는 다시 재입력이 일어나지 않기 때문에, 분할 상환 분석에 따른 시간 복잡도는 여전히 O(1)이다.

---