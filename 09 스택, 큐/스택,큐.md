# 09 스택, 큐
스택

- LIFO(Last-In-First-Out) 후입선출
- 잔뜩 쌓아둔 접시 → 마지막에 쌓은 접시를 제일 먼저 꺼내게 됨
- `push()` : 요소를 컬렉션에 추가한다.
- `pop()` : 아직 제거되지 않은 가장 최근에 삽입된 요소를 제거한다.
- 파이썬 리스트는 스택 연산인 푸시와 팝이 O(1)에 동작함.
- 스택 버퍼 오버플로(Stack Buffer Overflow): 꽉 찬 스택에 요소를 삽입하고자 할 때 스택에 요소가 넘쳐서 에러가 발생하는 것

큐

- FIFO(First-In-First-Out) 선입선출
- 줄을 선 사람들 → 가장 먼저 줄을 선 사람이 먼저 입장

파이썬의 리스트

- 스택, 큐의 모든 연산을 지원
- 리스트는 동적 배열로 구현되어 있어 큐의 연산을 수행하기에는 효율적x → 큐를 위해서는 데크(Deque)라는 별도의 자료형을 사용해야 좋은 성능을 낼 수 있음.

> 연결 리스트를 이용한 스택 ADT 구현
> 

```python
# 연결 리스트를 담을 Node 클래스 정의
class Node:
		def __init__(self, item, next):
				self.item = item # 노드의 값은 item
				self.next = next # 다음 노드를 가리키는 포인터는 next

# 스택의 연산 push(), pop()을 담은 Stack 클래스 정의
class Stack:
    def __init__(self):
        self.last = None
    
		# push()는 연결 리스트에 요소를 추가하면서 가장 마지막 값을 next로 지정하고, 포인터인 last는 가장 마지막으로 이동시킨다.
    def push(self, item):
        self.last = Node(item, self.last)
    
		# pop()은 가장 마지막 아이템을 끄집어내고 last 포인터를 한 칸 앞으로 전진 시킨다. 즉 이전에 추가된 값을 가리키게 한다.
    def pop(self):
        item = self.last.item
        self.last = self.last.next
        return item

stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
stack.push(4)
stack.push(5)

for _ in range(5):
    print(stack.pop())

''' 결과
5
4
3
2
1
'''
```

---

## 20 [유효한 괄호](https://leetcode.com/problems/valid-parentheses/)

괄호로 된 입력값이 올바른지 판별하라.

### 풀이 1. 스택 일치 여부 판별

(, [, { 는 스택에 푸시하고, ),],} 를 만날 때 스택에서 팝한 결과가 매핀 테이블 결과와 매칭되는지 확인하면 된다. 먼저 매핑 테이블을 만들어 놓고 테이블에 존재하지 않으면 무조건 푸시하고, 팝했을 때 결과가 일치하지 않으면 False를 리턴한다.

---

## 21 [중복 문자 제거](https://leetcode.com/problems/remove-duplicate-letters/)

중복된 문자를 제외하고 사전식 순서로 나열하라.

### 풀이 1. 재귀를 이용한 분리

### 풀이 2. 스택을 이용한 문자 제거

<aside>
💡 `collections.Counter()`

</aside>

---