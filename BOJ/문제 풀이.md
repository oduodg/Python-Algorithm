# 문제 풀이

## [2606. 바이러스](https://www.acmicpc.net/problem/2606)

### dfs 풀이

1. 필요한 변수 입력받기
2. 컴퓨터 번호 쌍 그래프 생성 
    
    → `collections.defaultdict(list)`
    
    - 양방향이므로 양쪽 인덱스에 append 해줄 것
3. 방문 노드를 담을 배열 visited 생성
    - 노드가 1부터 시작이므로 인덱스를 맞춰주기 위해 배열 크기는 n+1로 생성
4. dfs(v) # v는 방문 노드
    1. 노드 v에 대해 방문 처리
    2. 노드 v와 인접한 노드들을 for문으로 돌면서 방문하지 않은 노드가 있다면 재귀 호출
    3. 방문 노드 배열에서 True를 count 한 값 - 1(1번 컴퓨터 제외)을 리턴

---

## [2775. 부녀회장이 될테야](https://www.acmicpc.net/problem/2775)

### 재귀 풀이

1. 0층의 n호는 n명이 거주하고 있으므로, k = 0일 때는 n을 리턴
2. k-1층의 1호부터 n호까지의 재귀를 호출하면서 result에 더해 리턴한다.

→ 시간 초과

### 배열 풀이

1. 배열의 이전 인덱스 값을 다음 인덱스 값에 더해 가면서 배열의 값을 업데이트 시킨다.

---

## [18870. 좌표 압축](https://www.acmicpc.net/problem/18870)

- 한 줄에 여러 변수 입력받기

→ `list(map(int, input().split()))` // 리스트로 출력됨

- 딕셔너리 컴프리헨션
- 아스테리스크(*) 언패킹: 리스트에서 각 요소의 값만 출력하고 싶을 때

```python
>>> fruits = ['lemon', 'pear', 'watermelon', 'tomato']
>>> fruits
['lemon', 'peer', 'watermelon', 'tomato']
>>> print(*fruits)
lemon pear watermelon tomato
```

---

## [18258. 큐 2](https://www.acmicpc.net/problem/18258)

- 음수, 0, 양수, 최솟값, 최댓값 → 반드시 확인해 볼 엣지케이스 명심!!
    
    (한 자리수, 두 자리수, 세 자리수 .. 도 함께 확인하기)
    
- 처음에 `q.append(command[-1])`로 코드를 짰기 때문에 정수가 두자리 수 이상일 때는 처리가 안됐음..
- command 자체를 split()해서 받아올 것.

---

## [7568. 덩치](https://www.acmicpc.net/problem/7568)

음,, 어떻게든 풀어보려고 이렇게 저렇게 생쇼를 했다. 

- 중복순위를 어떻게 정렬해야하는지에 대한 고민을 많이 했다.
- 그냥 2중 for문을 돌려서 rank를 증가시키면서 파악하고 출력하면 되는 문제였다..

---

## [11718. 그대로 출력하기](https://www.acmicpc.net/problem/11718)

Point: 입력값이 몇 번 주어지는지 알 수 없는 상태에서 입력된 값 그대로 출력하기 

- `try ~ except` 를 사용
    
    → `EOFError` 예외 처리 (End Of File: 입력값이 들어오지 않는 상태)
- `import sys` 입력 가속해서 하면 출력 초과가 뜨는데 왜 그런지 모르겠다..
  
---

## [1806. 부분합](https://www.acmicpc.net/problem/1806)

반나절의 삽질 끝에,, 다른 풀이를 참고하여 성공했다.

- “연속된 수들”의 부분합이므로 수열 리스트를 정렬하면 안된다. → 문제를 정확하게 잘 읽자.
- 시간을 조금이라도 줄이기 위해, 맨 처음 수열의 전체 합이 s보다 작으면 0을 리턴하도록 했다.
- 투 포인터를 사용하는데, strat와 end 모두 0에서 시작시킨다.
- length를 최솟값으로 업데이트 시키기 위해, length는 입력의 최대값(100,000) +1 을 하여 100,001로 선언한다.
- total ≥ s 인 경우,
    
    → length는 현재의 length값과 end-start (끝 인덱스에서 시작 인덱스를 뺀 값) 중 작은 값으로 업데이트한다.
    
    → total에서 start 인덱스의 값을 빼주고, start는 1 증가시킨다.
    
- total < s인 경우,
    
    → end가 끝까지 가면, start를 증가시켜도 total값은 더 줄어드므로(앞의 값을 빼주니까) 바로 반복문을 탈출시킨다.
    
    → total에 end 인덱스의 값을 더해주고, end는 1 증가시킨다.
    
- length가 100,001이 아닌 경우 length를 리턴하고, 그 외의 경우엔 0을 리턴한다.

---

## [1920.수 찾기](https://www.acmicpc.net/problem/1920)

a와 b를 list로 받으면 시간초과가 나지만, a를 set으로 b는 그냥 map타입으로 하면 성공한다.

- List의 in 연산자의 시간 복잡도는 O(N)
- Set과 Dictionary의 in 연산자의 시간 복잡도는 O(1)

---

## [11286.절댓값 힙](https://www.acmicpc.net/problem/11286)

heap에 [절댓값, 입력값] 형태로 요소를 추가해주면, 절댓값이 작은 순서로 정렬된다. 출력할 때는 `heapq.heappop(heap)[1]` 로 입력값만 출력하면 된다.

---

## [1644.소수의 연속합](https://www.acmicpc.net/problem/1644)

BOJ 2581.소수 풀이를 참고하여 (set으로 에라토네스의 체 구현) 풀었는데, 메모리 초과가 뜸.

이유를 잘 모르겠다,, → 소수 리스트를 만들고 append 하는 방식으로 풀었더니 통과함.

---

## [1193.분수찾기](https://www.acmicpc.net/problem/1193)

수학적 규칙을 찾아서 공식을 잘 세워야함. 대각선의 규칙과 분모-분자 간의 규칙.

---

## [🥉𝟮 - 2231.분해합](https://www.acmicpc.net/problem/2231)

num = [0] * 1000001인 리스트를 만들고, 각 인덱스에 분해합을 저장하는 방식으로 했더니 시간초과 ㅎㅎ;

→ 리스트를 만들 필요없이 for문을 돌면서 변수 하나에 분해합을 저장하고, 입력값과 같으면 바로 리턴하고 for문을 다 돌면 분해합이 없다는 것이므로 0을 리턴한다.

---

## [🥈Ⅲ - 1463.1로 만들기](https://www.acmicpc.net/problem/1463)

- 3가지 연산을 진행했을 때, 가장 최솟값을 저장해야함.
- 이전 수에 대해서 연산 횟수를 미리 저장해둠.
- 연산 횟수를 증가시켜야 하므로 +1 하는 것 잊지말기.
- 인덱스 번호는 해당 정수를 의미함.

---

## [🥈Ⅴ - 1436.영화감독 숌](https://www.acmicpc.net/problem/1436)

처음에는 str(num).count(’6’) ≥ 3 으로 작성했는데, 문제를 다시 제대로 읽어보니 6이 **연속**으로 3개 이상이어야 한다. → 문제를 잘‼️ 읽자

- num = 665부터 시작해서 1씩 수를 증가시켜주고, str타입으로 변환했을 때 ‘666’이 들어있으면 n을 감소시키는 while문을 돌렸다.
- 마지막에 num을 출력해주면 된다.

---

## [🥈Ⅱ - 1912.연속합](https://www.acmicpc.net/problem/1912)

이중 for문으로 슬라이싱해서 모든 경우의 수를 탐색하는 코드를 짰더니 시간초과 → 시간복잡도 O(n^2)

이 문제는 DP로 풀어야한다. → 시간복잡도 O(n)

- 현재 값과 이전 값까지의 합 중 큰 값으로 업데이트한다.
- dp 배열 중 가장 큰 값을 출력한다.

*DP문제는 수열이 주어졌을 때, **규칙**을 찾고 수열의 크기와 **같은 크기의 DP 배열**이 필요하다.

---

## [🥈Ⅲ - 1966.프린터 큐](https://www.acmicpc.net/problem/1966)

처음 풀이는 런타임에러가 났는데, 확실히는 모르겠지만 top = max(priority) 의 top 변수 때문에 난 것 같다.

- 순서를 담을 인덱스 리스트를 만들고, `zip()` 을 이용해서 (우선순위, 인덱스) 값들이 담길 deque를 만들었다.
- target 문서를 target = (priority[m], m) 변수에 담아주고
- target 문서가 deque에 남아있는 동안 while문을 돌려준다.
- if: 맨 처음 문서의 우선순위가 가장 높다면, `popleft()` 를 해주고, cnt(출력 순서)를 +1 증가시킨다. 그리고 우선순위가 담겨있는 배열priority에서 max값을 `remove()` 함수를 이용하여 제거한다.
    
    → 여기서 알아야 할 점은 `리스트.remove(값)` 은 리스트에 동일한 값을 가진 동일한 요소들이 있더라도 리스트에서 **가장 먼저 발견된 요소 1개를 지워준다**는 것
    
    ```python
    idx = [1, 2, 3, 1]
    idx.remove(1)
    # idx = [2, 3, 1]
    ```
    
- else: `popleft()`한 값을 `append()`해서 맨 뒤에 다시 붙여준다.
- 마지막에 출력 순서 cnt를 출력해준다.

---

## [🥈Ⅲ - 4779.칸토어 집합](https://www.acmicpc.net/problem/4779)

재귀로 푸는 분할 정복 문제

- 재귀는 가장 작은 문제의 답과 패턴을 잘 이해하면 쉽게 풀 수 있는 것 같다.
- 입력 개수를 모를 때, 입력 받아오기
    
    ```python
    # 1. EOFError 처리
    while True:
    	try:
    		n = int(input())	
    		print(cantor(n))		
    	except EOFError:
    		break
    
    # 2. 표준 입력 -> 1번보다 2가 나은듯
    for n in map(int, sys.stdin):
    	print(cantor(n))
    ```