# etc

## [키패드 누르기](https://programmers.co.kr/learn/courses/30/lessons/67256)

Level1이라 만만하게 봤지만 처음 생각한 알고리즘대로 되지 않았다. 하지만 끝까지 혼자 풀려고 했고 성공!!

> 알고리즘

- 키패드의 *은 10으로, 0은 11으로, #은 12이라고 설정했다.
- 따라서 leftThumb = 10, rightThumb = 12로 시작한다.
- 주어진 배열 numbers의 number들을 for문으로 돌면서 answer에 ‘L’또는 ‘R’ 을 추가한다.
- 좌측 배열(1, 4, 7)의 조건 → 무조건 왼손이 입력
- 우측 배열(3, 6, 9)의 조건 → 무조건 오른손이 입력
    - 숫자가 아닌 *과 #은 입력하는 경우가 없으므로 제외했다.
- 중간 배열인(2, 5, 8, 0)의 조건
    - 맨 처음 숫자가 0인 경우는 number를 11로 변경해주어야 한다.
    - 왼손 엄지손가락과의 거리 측정과 오른손 엄지손가락과의 거리 측정을 한다.
        - 입력된 숫자와 현재 위치가 같다면 거리 = 0 이다.
        - `n = (현재 위치- 입력된 숫자)의 절댓값` 이라고 하면, `거리 = n // 3 + n % 3` 이다.
        - 왼손과의 거리와 오른손과의 거리를 비교한다.
- 배열 answer의 문자열로 합쳐서 return 한다.

---

## [두 개 뽑아서 더하기](https://programmers.co.kr/learn/courses/30/lessons/68644)

3분만에 풀 정도로 굉장히 쉬움.

> 알고리즘

- 이중 for문을 이용해 서로 다른 인덱스 두 개의 수를 더함.
- answer에 더한 값이 없으면 추가.
- 오름차순으로 정렬한 answer를 리턴

---

## [2016년](https://programmers.co.kr/learn/courses/30/lessons/12901)

> 알고리즘

- 각 날짜를 새해가 시작한 이후 몇 번째 날인지로 설정함. (ex: 1월 1일은 `1`일째, 2월 1일은 `32`일째)
- 1월 1일이 금요일이므로 1월 7일은 목요일임. → 7의 배수이면 목요일, 나머지 요일은 7로 나눈 나머지로 판단
- 각 월마다 일 수가 다르므로 해당 딕셔너리를 만듬 {1: 31, 2: 29, 3: 31, 4: 30 ... }
- 1부터 a까지 for문을 이용해 b에 각 월에 해당하는 일 수만큼 더해줌(1월 1일을 기준으로 몇 번째날인지)
- b를 7로 나눈 나머지를 이용해 요일을 판단하고 리턴

---

## [내적](https://programmers.co.kr/learn/courses/30/lessons/70128)

매우 쉬움.

> 알고리즘
 
- 리스트 컴프리헨션을 이용해 a[i] * b[i] 값을 담는 리스트를 생성
- sum함수를 이용하여 sum(리스트)를 리턴