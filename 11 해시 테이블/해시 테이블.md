# 11 해시 테이블
`해시 테이블` 또는 `해시 맵`은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형(ADT)을 구현하는 자료구조다.

해시 테이블

- 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 O(1)이다.
- 데이터 양에 관계 없이 빠른 성능을 기대할 수 있다.

## 해시

`해시 함수` : 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수

ABC → A1

1324BC → CB

AF32B → D5

특정 함수를 통과하면 2바이트의 고정 크기 값으로 매핑된다. 여기서 화살표 역할을 하는 함수가 바로 해시함수다.

`해싱` : 해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것

- 정보를 가능한 한 빠르게 저장하고 검색하기 위해 사용하는 중요한 기법 중 하나
- 최적의 검색이 필요한 분야에 사용되며, 심볼 테이블 등의 자료구조를 구현하기에도 적합

성능 좋은 해시 함수들의 특징

- 해시 함수 값 충돌의 최소화
- 쉽고 빠른 연산
- 해시 테이블 전체에 해시 값이 균일하게 분포
- 사용할 키의 모든 정보를 이용하여 해싱
- 해시 테이블 사용 효율이 높을 것

> 생일 문제
> 

생각보다 충돌은 쉽게 일어난다.

일반적인 상식(잘못된 상식)과는 달리, 충돌은 생각보다 쉽게 일어나므로 충돌을 최소화하는 일은 무엇보다 중요하다.

> 비둘기집 원리
> 

n개 아이템을 m개 컨테이너에 넣을 때, n>m이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어 있다는 원리

여러 번 충돌한다는 것은 그만큼 추가 연산을 필요로 하기 때문에 가급적 충돌은 최소화하는 것이 좋다.

> 로드 팩터
> 

해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것이다.

load factor = n/k

로드 팩터 비율에 따라서 해시 함수를 재작성해야 될지 또는 해시 테이블의 크기를 조정해야 할지를 결정한다. 또한 이 값은 해시 함수가 키들을 잘 분산해 주는지를 말하는 효율성 측정에도 사용된다.

- 자바 10에서는 해시맵의 디폴트 로드 팩터를 0.75로 정함
- '시간과 공간 비용의 적절한 절충안'

> 충돌
> 

아무리 좋은 해시 함수라도 충돌은 발생하게 된다.

> 개별 체이닝
> 

해시 테이블의 기본 방식이기도 한 개별 체이닝은 충돌 발생 시 연결 리스트로 연결하는 방식이다.

1. 키의 해시 값을 계산한다.
2. 해시 값을 이용해 배열의 인덱스를 구한다.
3. 같은 인덱스가 있다면 연결 리스트로 연결한다.

잘 구현한 경우 대부분의 탐색은 O(1)이지만 최악의 경우, 즉 모든 해시 충돌이 발생했다고 가정할 경우에는 O(n)이 된다.

> 오픈 어드레싱
> 

충돌 발생 시 탐사를 통해 빈 공간을 찾아나서는 방식이다.

사실상 무한정 저장할 수 있는 체이닝 방식과 달리, 오픈 어드레싱 방식은 전체 슬롯의 개수 이상은 저장할 수 없다. 충돌이 일어나면 테이블 공간 내에서 탐사를 통해 빈 공간을 찾아 해결하며, 이 때문에 개별 체이닝 방식과 달리, 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다.

`선형 탐사` : 오픈 어드레싱 방식 중 가장 간단한 방식으로 충돌이 발생할 경우 해당 위치부터 순차적으로 탐사를 하나씩 진행한다. 특정 위치가 선점되어 있으면 바로 그다음 위치를 확인하는 식이다. 이렇게 탐사를 진행하다가 비어 있는 공간을 발견하면 삽입하게 된다.

선형 탐사의 문제점

- 해시 테이블에 저장되는 데이터들이 고르게 분포되지 않고 뭉치는 경향이 있다는 점
- `클러스터링`: 해시 테이블 여기저기에 연속된 데이터 그룹이 생기는 현상
- 해시 테이블의 특정 위치에는 데이터가 몰리게 되고, 다른 위치에는 상대적으로 데이터가 거의 없는 상태가 될 수 있다. 클러스터링 현상은 탐사 시간을 오래 걸리게 하며, 전체적으로 해싱 효율을 떨어뜨리는 원인이 된다.

> 언어별 해시 테이블 구현 방식
> 

파이썬의 딕셔너리는 오픈 어드레싱 방식의 해시 테이블로 구현되어 있다.

---

## 28 [해시맵 디자인](https://leetcode.com/problems/design-hashmap/)

다음의 기능을 제공하는 해시맵을 디자인하라.

- put(key, value): 키, 값을 해시맵에 삽입한다. 만약 이미 존재하는 키라면 업데이트한다.
- get(key): 키에 해당하는 값을 조회한다. 만약 키가 존재하지 않는다면 -1을 리턴한다.
- remove(key): 키에 해당하는 키, 값을 해시맵에서 삭제한다.

### 풀이 1. 개별 체이닝 방식을 이용한 해시 테이블 구현

키, 값을 보관하고 연결 리스트로 처리할 별도의 객체를 구현해야 한다. → ListNode 클래스 정의

- `collections.defaultdict()`

---

## 29 [보석과 돌](https://leetcode.com/problems/jewels-and-stones/)

J는 보석이며, S는 갖고 있는 돌이다. S에는 보석이 몇 개나 있을까? 대소문자는 구분한다.

### 풀이1. 해시 테이블을 이용한 풀이

갖고 있는 돌 S의 각각의 개수를 모두 헤아린 다음, J의 각 요소를 키로 하는 각 개수를 합산하면 풀이할 수 있다.

### 풀이2. defaultdict를 이용한 비교 생략

defaultfict를 사용해 존재하지 않는 키에 대해 디폴트를 리턴해주는 풀이를 사용하면 코드 줄 수를 훨씬 더 줄일 수 있다.

### 풀이3. Counter로 계산 생략

Counter를 사용하면 코드를 더욱 짧게 줄일 수 있다. 각 개수를 게산하는 부분까지 자동으로 처리할 수 있기 때문이다. 

아울러 Counter는 존재하지 않는 키의 경우 KeyError를 발생하는 게 아니라 0을 출력해 주기 때문에, defaultdict와 마찬가지로 에러에 대한 예외 처리를 할 필요가 없다.

### 풀이4. 파이썬다운 방식

해시 테이블과는 관련이 없지만, 이 문제는 파이썬다운 방식으로 단 한 줄로 계산할 수 있다.

```python
J = "aA"
S = "aAAbbbb"

>>> [s for s in S]
['a', 'A', 'A, 'b', 'b', 'b', 'b']

>>> [s in J for s in S]
[True, True, True, False, False, False, False]

>>> sum(s in J for s in S) # True의 개수 리턴
3
```

---