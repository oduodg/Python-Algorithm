# 07 배열
: 배열은 값 또는 변수 엘리먼트의 집합으로 구성된 구조로, 하나 이상의 인덱스 또는 키로 식별된다.

자료구조 

- `메모리` 공간 기반의 연속 방식
    - `배열`: 크기를 지정하고 해당 크기만큼의 연속된 메모리 공간을 할당받는 작업을 수행하는 자료형, 어느 위치에나 O(1)에 조회가 가능하다는 장점이 있다.
        - `정적 배열`: 크기가 고정되어 있으며, 한번 생성한 배열은 크기를 변경하는 것이 불가능
        - `동적 배열`: 크기를 지정하지 않고 자동으로 리사이징하는 배열(파이썬의 `리스트`), 미리 초깃값을 작게 잡아 배열을 생성하고, 데이터가 추가되면서 꽉 채워지면, 늘려주고 모두 복사하는 식(대개는 `더블링` 방식)
- `포인터` 기반의 연결 방식
    - `연결 리스트`

---

## 07 [두수의 합](https://leetcode.com/problems/two-sum/)

덧셈하여 타겟을 만들 수 있는 배열의 두 숫자 **인덱스를 리턴**하라.

### 풀이1. 브루트 포스로 계산

브루트 포스: 배열을 2번 반복하면서 모든 조합을 더해서 일일이 확인해보는 무차별 대입 방식

마지막 요소들까지 모두 차례대로 비교해 가며 정답을 찾을 때까지 계속 진행한다. 시간 복잡도는 O(n^2)이다.

### 풀이2. in을 이용한 탐색

모든 조합을 비교하지 않고, 타겟에서 첫 번째 값을 뺀 값 target - n 이 존재하는지 탐색하는 문제로 변경해보자.

`enumerate()` : 반복문을 사용할 때 리스트의 순서값, 즉 인덱스의 정보가 필요한 경우가 있다. enumerate() 함수는 **리스트의 원소에 순서값을 부여해주는 함수**이다.

```python
item = ["First", "Second", "Third"]
for val in enumerate(item):
		print(val)

>>> (0, 'First')
		(1, 'Second')
		(2, 'Third')
```

시간 복잡도는 O(n).

### 풀이3. 첫 번째 수를 뺀 결과 키 조회

비교나 탐색 대신 한 번에 정답을 찾을 수 있는 방법.

### 풀이4. 조회 구조 개선

딕셔너리 저장과 조회를 2개의 for문으로 각각 처리했던 방식을 좀 더 개선해서 이번에는 하나의 for로 합쳐서 처리해보자.

*딕셔너리는 키 값을 조회함.

```python
dict1 = {
    "바늘": "실",
    "연필": "지우개",
    "라면": "볶음밥",
    "소풍": "김밥"
}
if "바늘" in dict1:
    print(True)
else:
    print(False)
>>> True

if "실" in dict1:
    print(True)
else:
    print(False)
>>> False
```

### 풀이5. 투 포인터 이용

(리스트가 오름차순으로 정렬되어 있다는 가정 하에 )왼쪽 포인터와 오른쪽 포인터의 합이 타겟보다 크다면 오른쪽 포인터를 왼쪽으로, 작다면 왼쪽 포인터를 오른쪽으로 옮기면서 값을 조정하는 방식이다.

---

## 08 [빗물 트래핑](https://leetcode.com/problems/trapping-rain-water/)

높이를 입력받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라.

### 풀이1. 투 포인터를 최대로 이동

왼쪽 포인터와 오른쪽 포인터가 최대 높이의 막대로 이동할 때까지, 각각 좌우 기둥 최대 높이 left_max, right_max 가 현재 높이와의 차이만큼 물 높이 volume을 더해 나간다.

좌우 어느 쪽이든 낮은 쪽은 높은 쪽을 향해서 포인터가 가운데로 점점 이동한다. 오른쪽이 크다면 left +=1로 왼쪽이 이동하고, 그렇지 않다면(즉 왼쪽이 크다면) right -=1 로 오른쪽이 이동한다. 이렇게 하면 가장 높이가 높은 막대, '최대' 지점에서 좌우 포인터가 서로 만나게 되며 O(n)에 풀이가 가능하다.

### 풀이2. 스택 쌓기

봐도 모르겠다..