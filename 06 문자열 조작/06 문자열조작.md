# 문자열 조작
: 문자열을 변경하거나 분리하는 등의 여러 과정

## 01 [유효한 팰린드롬](https://leetcode.com/problems/valid-palindrome/)

주어진 문자열이 팰린드롬인지 확인하라. 대소문자를 구분하지 않으며, 영문자와 숫자만을 대상으로 한다.

팰린드롬: 앞뒤가 똑같은 단어나 문장으로, 뒤집어도 같은 말이 되는 단어 또는 문장

### 풀이1. 리스트로 변환

1. 빈 리스트를 생성하고, 소문자로 모두 바꾼 영문자와 숫자만을 추가한다.
    1. 영문자와 숫자만을 대상으로 하므로 ,나 : 같은 기호는 제거한다.
        
        `isalnum()` : 영문자, 숫자 여부를 판별하는 함수
        
    2. 대소문자를 구분하지 않으므로 모두 소문자로 변환한다.
        
        `lower()` : 소문자로 변환하는 함수
        
2. 팰린드롬 여부를 판별하자. 

→ `pop()` 을 사용해 맨 앞의 요소와 맨 뒤의 요소가 같은지 비교한다.

`pop()` : 리스트의 맨 마지막 요소를 반환하고 그 요소는 삭제한다.

`pop(x)` : 리스트의 x번째 요소를 반환하고 그 요소는 삭제한다.

`pop(0)` : 리스트의 맨 앞 요소를 반환하고 그 요소는 삭제한다.

### 풀이2. 데크 자료형을 이용한 최적화

풀이1에 대해 **자료형을 데크로 선언**하는 것만으로 성능을 좀 더 높인다.

- 변수 타입 어노테이션 → `typing 모듈`
    - 변수명: 타입 = 값
    
    ```python
    name: str = "John Doe"
    
    age: int = 25
    
    emails: list: ["john1@doe.com", "john2@doe.com"]
    
    address: dict = {
      "street": "54560 Daugherty Brooks Suite 581",
      "city": "Stokesmouth",
      "state": "NM",
      "zip": "80556"
    }
    ```
    
- 데크(Deque)
- `collections 라이브러리` : 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리

### 풀이3. 슬라이싱 사용

1. 입력받은 문자열을 모두 소문자로 변환한다.
- `.lower()`
1. 정규표현식을 사용해서 불필요한 문자(영문자와 숫자 이외)를 필터링한다.
- `re모듈`
- `정규표현식`
    
    `^` : 맨 앞에 `^` 표시를 쓰면 not의 의미. `^` 뒤에 나오는 표현을 제외한 것을 매치시킨다. 주의할 것은 맨 앞에 위치한 `^` 만 not의 역할이며, 이후에 등장하는 `^` 는 기호 그대로를 뜻한다.
    
    `[^a-z0-9]` : 소문자와 숫자가 아닌 것들을 나타냄.
    
1. 슬라이싱을 사용해 입력 문자열을 뒤집은 것과 원본이 같은지 확인
- `s[::-1]` : 문자열 s 뒤집기
---

## 02 [문자열 뒤집기](https://leetcode.com/problems/reverse-string/)

문자열을 뒤집는 함수를 작성하라. 입력값은 문자 배열이며, **리턴 없이 리스트 내부를 직접 조작**하라.

### 풀이1. 투 포인터를 이용한 스왑

`투 포인터` : 2개의 포인터를 이용해 범위를 조정해가며 풀이하는 방식

여기서는 점점 더 범위를 좁혀 가며 스왑하는 형태로 풀이할 수 있다.

1. 왼쪽 포인터 left, 오른쪽 포인터 right 생성
2. left < right 조건일 때, left가 가리키는 값과 right이 가리키는 값을 스왑 시키고,
3. left += 1, right -= 1 해준다.

### 풀이2. 파이썬다운 방식

입력값이 리스트로 제공되므로 `reverse()` 함수를 사용하면 뒤집을 수 있다.

`reverese()` : 리스트에만 제공되며, 리스트를 뒤집는다. 반환값이 없음에 주의!
---

## 03 [로그 파일 재정렬](https://leetcode.com/problems/reorder-data-in-log-files/)

로그를 재정렬하라. 기준은 다음과 같다.

1. 로그의 가장 앞 부분은 식별자다.
2. 문자로 구성된 로그가 숫자 로그보다 앞에 온다.
3. 식별자는 순서에 영향을 끼치지 않지만, 문자가 동일할 경우 식별자 순으로 한다.
4. 숫자 로그는 입력 순서대로 한다.

### 풀이1. 람다와  + 연산자를 이용

1. 문자로 구성된 로그가 숫자 로그보다 앞에 오므로, 문자와 숫자를 구분한다.
- `isdigit()`
1. 문자 로그는 letters에 숫자 로그는 digits에 추가한다.
2. 문자 로그를 모아둔 letters를 람다식으로 정렬한다.
- `람다 표현식` : 식별자 없이 실행 가능한 함수로 함수 선언 없이도 하나의 식으로 함수를 단순하게 표현할 수 있다.
- 정렬 기준은 식별자를 제외한 문자열 [1:]로 하고, 동일한 경우 후순위로 식별자 [0]을 지정해 정렬한다.
1. letters와 digits를 합쳐서 리턴한다. (리스트 합치기)

---

## 04 [가장 흔한 단어](https://leetcode.com/problems/most-common-word/)

금지된 단어를 제외한 가장 흔하게 등장하는 단어를 출력하라. 대소문자 구분을 하지 않으며, 구두점(마침표, 쉼표 등) 또한 무시한다.

### 풀이1. 리스트 컴프리헨션, Counter 객체 사용

1. 입력값에 대한 전처리 
- 정규식으로 단어 문자가 아닌 모든 문자를 공백으로 치환한다.

정규표현식의 특수 문자를 판단하려면 \를 붙여야 합니다. 여기서 문자열 앞에 r을 붙여주면 원시(raw) 문자열이 되어 \를 붙이지 않아도 특수 문자를 그대로 판단할 수 있습니다.

- 소문자로 변환한다.
1. 금지된 단어를 제외한 단어들만 단어목록에 추가한다.
2. `collections.Counter` 를 사용해 개수를 담아두는 변수를 만들고 단어의 개수를 센다.
3. 딕셔너리 변수에서 가장 흔하게 등장하는 단어의 첫 번째 값을 `.most_common(1)` 으로 추출한다.
- `.most_common(k)` : 데이터의 개수가 많은 순으로 정렬된 배열에서 k개 만큼 리턴한다.