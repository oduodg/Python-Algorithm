# 12 그래프
`비선형 자료구조`: 데이터 요소가 순차적으로 또는 선형으로 배열되지 않는 자료구조

비선형 자료구조는 선형과 달리 멀티 레벨로 구성된다. 탐색이 복잡하고 선형에 비해 구현하기도 다소 번잡한 편이지만, 메모리를 좀 더 효율적으로 활용할 수 있다는 장점이 있다. 

`그래프`: 객체의 일부 쌍(pair)들이 '연관되어' 있는 객체 집합 구조를 말한다.

> 오일러 경로
> 

간선 기준

> 해밀턴 경로
> 

정점 기준

해밀턴 경로는 각 정점을 한 번씩 방문하는 무향 또는 유향 그래프 경로를 말한다.

(ex. 외판원 문제)

> 그래프 순회
> 

`그래프 순회`란 `그래프 탐색` 이라고도 불리우며 그래프의 각 정점을 방문하는 과정을 말한다.

`깊이 우선 탐색(DFS)`와 `너비 우선 탐색(BFS)`가 있다.

그래프를 표현하는 방법에는 크게 `인접 행렬` 과 `인접 리스트` 의 2가지 방법이 있다.

`인접 리스트` 는 출발 노드를 키로, 도착 노드를 값으로 표현할 수 있다. 도착 노드는 여러 개가 될 수 있으므로 리스트 형태가 된다.(파이썬의 딕셔너리 자료형으로 나타낼 수 있다.)

```python
graph = {
    1: [2, 3, 4],
    2: [5],
    3: [5],
    4: [],
    5: [6, 7],
    6: [],
    7: [3],
}
```

> DFS(깊이 우선 탐색)
> 

### 재귀 구조로 구현

주로 스택으로 구현하거나 재귀로 구현한다.(재귀 구현이 더 선호됨) 백트래킹을 통해 뛰어난 효용을 보인다.

```python
def recursive_dfs(v, discovered=[]):
    discovered.append(v)
    for w in graph[v]:
        if w not in discovered:
            discovered = recursive_dfs(w, discovered)
    return discovered

print(recursive_dfs(1))
>>> 1 -> 2 -> 5 -> 6 -> 7 -> 3 -> 4
```

재귀 DFS는 사전식 순서로 방문한다.

### 스택을 이용한 반복 구조로 구현

```python
def iterative_dfs(start_v):
    discovered = []
    stack = [start_v]
    while stack:
        v = stack.pop()
        if v not in discovered:
            discovered.append(v)
            for w in graph[v]:
                stack.append(w)
    return discovered

print(iterative_dfs(1))
>>> 1 -> 4 -> 3 -> 5 -> 7 -> 6 -> 2

# stack = [1]
# stack = [], v = 1, discovered = [1], stack = [2,3,4]
# stack = [2,3], v = 4, discovered = [1,4], stack = [2,3]
# stack = [2], v = 3, discovered = [1,4,3], stack = [2,3,5]
# stack = [2,3], v = 5, discovered = [1,4,3,5], stack = [2,3,5,6,7]
# stack = [2,3,5,6], v = 7, discovered = [1,4,3,5,7], stack = [2,3,5,6,3]
# stack = [2,3,5,6], v = 3
# stack = [2,3,5], v = 6, discovered = [1,4,3,5,7,6], stack = [2,3,5]
# stack = [2,3], v = 5
# stack = [2], v = 3
# stack = [], v = 2, discovered = [1,4,3,5,7,6,2], stack = []
```

반복 DFS는 역순으로 방문한다. 스택으로 구현하다 보니 가장 마지막에 삽입된 노드부터 꺼내서 반복하게 되고 이 경우 인접 노드에서 가장 최근에 담긴 노드, 즉 가장 마지막부터 방문하기 때문이다.

> BFS(너비 우선 탐색)
> 

주로 큐로 구현하며, 그래프의 최단 경로를 구하는 문제 등에 사용된다. DFS보다 쓰임새는 적지만, 최단 경로를 찾는 다익스트라 알고리즘 등에 매우 유용하게 쓰인다.

### 큐를 이용한 반복 구조로 구현

스택을 이용하는 DFS와 달리, BFS를 반복 구조로 구현할 때는 큐를 이용한다. 

```python
def iterative_bfs(start_v):
    discovered = [start_v]
    queue = [start_v]
    while queue:
        v = queue.pop(0)
        for w in graph[v]:
            if w not in discovered:
                discovered.append(w)
                queue.append(w)
    return discovered

print(iterative_bfs(1))
>>> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7
# discovered = [1], queue = [1]
# queue = [], v = 1, discovered = [1,2,3,4], queue = [2,3,4]
# queue = [3,4], v = 2, discovered = [1,2,3,4,5], queue = [3,4,5]
# queue = [4,5], v = 3
# queue = [5], v = 4
# queue = [], v = 5, discovered = [1,2,3,4,5,6,7], queue = [6,7]
# queue = [7], v = 6
# queue = [], v = 7
```

모든 인접 간선을 추출하고 도착점인 정점을 큐에 삽입한다. 단계별 차례인 숫자 순으로 실행됐으며, 1부터 순서대로 각각의 인접 노드를 우선으로 방문하는 너비 우선 탐색이 잘 실행됐다.

### 재귀 구현 불가

→ BFS는 재귀로 구현할 수 없다.

> 백트래킹
> 

`백트래킹` 은 해결책에 대한 후보를 구축해 나아가다 가능성이 없다고 판단되는 즉시 후보를 포기(백트랙BackTrack)해 정답을 찾아가는 범용적인 알고리즘으로 제약 충족 문제에 특히 유용하다.

백트래킹은 DFS보다 좀 더 광의의 의미를 지닌다. 백트래킹은 탐색을 하다가 더 갈 수 없으면 왔던 길을 되돌아가 다른 길을 찾는다는 데서 유래했다. 백트래킹은 DFS와 같은 방식으로 탐색하는 모든 방법을 뜻하며, DFS는 백트래킹의 골격을 이루는 알고리즘이다. 백트래킹은 주로 **재귀**로 구현하며, 알고리즘마다 DFS 변형이 조금씩 일어나지만 기본적으로 모두 DFS의 범주에 속한다.

> 제약 충족 문제
> 

백트래킹은 제약 충족 문제를 풀이하는 데 필수적인 알고리즘이다. 가지치기를 통해 제약 충족 문제를 최적화 하기 때문이다.

`제약 충족 문제` 란 수많은 제약 조건을 충족하는 상태를 찾아내는 수학 문제를 일컫는다.

제약 충족 문제는 대표적으로 스도쿠처럼 1에서 9까지 숫자를 한 번만 넣는(제약 조건 충족) 정답(상태)을 찾아내는 모든 문제 유형을 말한다.

---

## 32 [섬의 개수](https://leetcode.com/problems/number-of-islands/)

1을 육지로, 0을 물로 가정한 2D 그리드 맵이 주어졌을 때, 섬의 개수를 계산하라. (연결되어 있는 1의 덩어리 개수를 구하라.)

### 풀이1. DFS로 그래프 탐색

쾨니히스베르크의 다리 문제처럼 반드시 그래프 모양이 아니더라도 그래프형으로 변환해서 풀이할 수 있음을 확인해보는 좋은 문제다. 동서남북이 모두 연결된 그래프로 가정하고 동일한 형태로 처리할 수 있으며, 네 방향 각각 DFS 재귀를 이용해 탐색을 끝마치면 1이 증가하는 형태로 육지의 개수를 파악할 수 있다.

동서남북이 모두 연결된 그래프로 가정하고 동일한 형태로 처리할 수 있으며, 네 방향 각각 DFS 재귀를 이용해 탐색을 끝마치면 1이 증가하는 형태로 육지의 개수를 파악할 수 있다.

DFS 탐색을 하는 dfs() 함수는 동서남북을 모두 탐색하면서 재귀호출한다.

<aside>
💡 중첩 함수: 함수 내에 위치한 또 다른 함수로, 바깥에 위치한 함수들과 달리 부모 함수의 변수를 자유롭게 읽을 수 있다는 장점이 있다.

</aside>

---

## 33 [전화 번호 문자 조합](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

2에서 9까지 숫자가 주어졌을 때 전화 번호로 조합 가능한 모든 문자를 출력하라.

### 풀이1. 모든 조합 탐색

digits는 입력값이며, 각 자릿수에 해당하는 키판 배열 dic을 DFS로 탐색하면 결과가 완성된다. 입력값을 자릿수로 쪼개어 반복하고, 숫자에 해당하는 모든 문자열을 반복하면서 마찬가지로 문자 단위로 재귀 탐색한다.

dfs() 함수는 자릿수가 동일할 때까지 재귀 호출을 반복하다 끝까지 탐색하면 결과를 추가하고 리턴한다.

---

## 34 [순열](https://leetcode.com/problems/permutations/)

서로 다른 정수를 입력받아 가능한 모든 순열을 리턴하라..

### 풀이1. DFS를 활용한 순열 생성

이전 값을 하나씩 덧붙여 계속 재귀 호출을 진행하다 리프 노드에 도달한 경우, 즉 len(elements) == 0일 때 결과를 하나씩 담는다. 중요한 부분은 결과를 추가할 때 prev_elements[ : ]로 처리해야 한다는 점이다. 파이썬은 모든 객체를 참조하는 형태로 처리되므로 만약 result.append(prev_elements)를 하게 되면 결과 값이 추가되는 게 아닌 prev_elements에 대한 참조가 추가되며, 이 경우 참조된 값이 변경될 경우 같이 바뀌게 된다. 따라서 반드시 값을 복사하는 형태로 참조 관계를 갖지 않도록 처리해야 한다.

### 풀이2. itertools 모듈 사용

파이썬의 `itertools 모듈` 은 반복자 생성에 최적화된 효율적인 기능들을 제공한다.

<aside>
💡 객체 복사

</aside>

참조가 되지 않도록 값 자체를 복사하려면 

1) [ : ]로 처리

2) copy() 메소드

3) copy모듈의 deepcopy() 메소드

---

## 35 [조합](https://leetcode.com/problems/combinations/)

전체 수 n을 입력받아 k개의 조합을 리턴하라.

### 풀이1. DFS로 k개 조합 생성

k개의 조합만을 생성해야 한다는 제약 조건이 추가된 문제다. 따라서 dfs() 함수에서 k 값을 별도로 전달받아 1씩 줄여나가며 재귀 호출하는 구조로, k가 0이 되면 바로 빠져나가는 로직을 추가한다.

### 풀이2. itertools 모듈 사용

- `itertools.combinations()`

---

## 36 [조합의 합](https://leetcode.com/problems/combination-sum/)

숫자 집합 candidates를 조합하여 합이 target이 되는 원소를 나열라라. 각 원소는 중복으로 나열 가능하다.

### 풀이1. DFS로 중복 조합 그래프 탐색

dfs() 함수의 첫 번째 파라미터는 합을 갱신해나갈 csum(candidates_sum이라는 의미),  두 번째 파라미터는 순서(자기 자신을 포함), 세 번째 파라미터는 지금까지의 탐색 경로로 정한다.

종료 조건은 2가지의 경우이다.

- csum < 0 : 목표값을 초과한 경우로 탐색 종료
- csum  == 0 : csum의 초기값은 target이며, 따라서 csum의 0은 target과 일치하는 정답이므로 결과 리스트에 추가하고 탐색 종료

---

## 37 [부분 집합](https://leetcode.com/problems/subsets/)

모든 부분 집합을 리턴하라.

### 풀이1. 트리의 모든 DFS 결과

트리를 구성하고 트리를 DFS하는 문제로 풀이할 수 있다. 부분 집합은 모든 탐색의 경로가 결국 정답이 되므로, 탐색할 때마다 매번 결과를 추가하면 된다.