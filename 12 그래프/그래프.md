# 12 그래프
`비선형 자료구조`: 데이터 요소가 순차적으로 또는 선형으로 배열되지 않는 자료구조

비선형 자료구조는 선형과 달리 멀티 레벨로 구성된다. 탐색이 복잡하고 선형에 비해 구현하기도 다소 번잡한 편이지만, 메모리를 좀 더 효율적으로 활용할 수 있다는 장점이 있다. 

`그래프`: 객체의 일부 쌍(pair)들이 '연관되어' 있는 객체 집합 구조를 말한다.

> 오일러 경로
> 

간선 기준

> 해밀턴 경로
> 

정점 기준

해밀턴 경로는 각 정점을 한 번씩 방문하는 무향 또는 유향 그래프 경로를 말한다.

(ex. 외판원 문제)

> 그래프 순회
> 

`그래프 순회`란 `그래프 탐색` 이라고도 불리우며 그래프의 각 정점을 방문하는 과정을 말한다.

`깊이 우선 탐색(DFS)`와 `너비 우선 탐색(BFS)`가 있다.

그래프를 표현하는 방법에는 크게 `인접 행렬` 과 `인접 리스트` 의 2가지 방법이 있다.

`인접 리스트` 는 출발 노드를 키로, 도착 노드를 값으로 표현할 수 있다. 도착 노드는 여러 개가 될 수 있으므로 리스트 형태가 된다.(파이썬의 딕셔너리 자료형으로 나타낼 수 있다.)

```python
graph = {
    1: [2, 3, 4],
    2: [5],
    3: [5],
    4: [],
    5: [6, 7],
    6: [],
    7: [3],
}
```

> DFS(깊이 우선 탐색)
> 

### 재귀 구조로 구현

주로 스택으로 구현하거나 재귀로 구현한다.(재귀 구현이 더 선호됨) 백트래킹을 통해 뛰어난 효용을 보인다.

```python
def recursive_dfs(v, discovered=[]):
    discovered.append(v)
    for w in graph[v]:
        if w not in discovered:
            discovered = recursive_dfs(w, discovered)
    return discovered

print(recursive_dfs(1))
>>> 1 -> 2 -> 5 -> 6 -> 7 -> 3 -> 4
```

재귀 DFS는 사전식 순서로 방문한다.

### 스택을 이용한 반복 구조로 구현

```python
def iterative_dfs(start_v):
    discovered = []
    stack = [start_v]
    while stack:
        v = stack.pop()
        if v not in discovered:
            discovered.append(v)
            for w in graph[v]:
                stack.append(w)
    return discovered

print(iterative_dfs(1))
>>> 1 -> 4 -> 3 -> 5 -> 7 -> 6 -> 2

# stack = [1]
# stack = [], v = 1, discovered = [1], stack = [2,3,4]
# stack = [2,3], v = 4, discovered = [1,4], stack = [2,3]
# stack = [2], v = 3, discovered = [1,4,3], stack = [2,3,5]
# stack = [2,3], v = 5, discovered = [1,4,3,5], stack = [2,3,5,6,7]
# stack = [2,3,5,6], v = 7, discovered = [1,4,3,5,7], stack = [2,3,5,6,3]
# stack = [2,3,5,6], v = 3
# stack = [2,3,5], v = 6, discovered = [1,4,3,5,7,6], stack = [2,3,5]
# stack = [2,3], v = 5
# stack = [2], v = 3
# stack = [], v = 2, discovered = [1,4,3,5,7,6,2], stack = []
```

반복 DFS는 역순으로 방문한다. 스택으로 구현하다 보니 가장 마지막에 삽입된 노드부터 꺼내서 반복하게 되고 이 경우 인접 노드에서 가장 최근에 담긴 노드, 즉 가장 마지막부터 방문하기 때문이다.

> BFS(너비 우선 탐색)
> 

주로 큐로 구현하며, 그래프의 최단 경로를 구하는 문제 등에 사용된다. DFS보다 쓰임새는 적지만, 최단 경로를 찾는 다익스트라 알고리즘 등에 매우 유용하게 쓰인다.

### 큐를 이용한 반복 구조로 구현

스택을 이용하는 DFS와 달리, BFS를 반복 구조로 구현할 때는 큐를 이용한다. 

```python
def iterative_bfs(start_v):
    discovered = [start_v]
    queue = [start_v]
    while queue:
        v = queue.pop(0)
        for w in graph[v]:
            if w not in discovered:
                discovered.append(w)
                queue.append(w)
    return discovered

print(iterative_bfs(1))
>>> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7
# discovered = [1], queue = [1]
# queue = [], v = 1, discovered = [1,2,3,4], queue = [2,3,4]
# queue = [3,4], v = 2, discovered = [1,2,3,4,5], queue = [3,4,5]
# queue = [4,5], v = 3
# queue = [5], v = 4
# queue = [], v = 5, discovered = [1,2,3,4,5,6,7], queue = [6,7]
# queue = [7], v = 6
# queue = [], v = 7
```

모든 인접 간선을 추출하고 도착점인 정점을 큐에 삽입한다. 단계별 차례인 숫자 순으로 실행됐으며, 1부터 순서대로 각각의 인접 노드를 우선으로 방문하는 너비 우선 탐색이 잘 실행됐다.

### 재귀 구현 불가

→ BFS는 재귀로 구현할 수 없다.

> 백트래킹
> 

`백트래킹` 은 해결책에 대한 후보를 구축해 나아가다 가능성이 없다고 판단되는 즉시 후보를 포기(백트랙BackTrack)해 정답을 찾아가는 범용적인 알고리즘으로 제약 충족 문제에 특히 유용하다.

백트래킹은 DFS보다 좀 더 광의의 의미를 지닌다. 백트래킹은 탐색을 하다가 더 갈 수 없으면 왔던 길을 되돌아가 다른 길을 찾는다는 데서 유래했다. 백트래킹은 DFS와 같은 방식으로 탐색하는 모든 방법을 뜻하며, DFS는 백트래킹의 골격을 이루는 알고리즘이다. 백트래킹은 주로 **재귀**로 구현하며, 알고리즘마다 DFS 변형이 조금씩 일어나지만 기본적으로 모두 DFS의 범주에 속한다.

> 제약 충족 문제
> 

백트래킹은 제약 충족 문제를 풀이하는 데 필수적인 알고리즘이다. 가지치기를 통해 제약 충족 문제를 최적화 하기 때문이다.

`제약 충족 문제` 란 수많은 제약 조건을 충족하는 상태를 찾아내는 수학 문제를 일컫는다.

제약 충족 문제는 대표적으로 스도쿠처럼 1에서 9까지 숫자를 한 번만 넣는(제약 조건 충족) 정답(상태)을 찾아내는 모든 문제 유형을 말한다.

---

## 32 [섬의 개수](https://leetcode.com/problems/number-of-islands/)

1을 육지로, 0을 물로 가정한 2D 그리드 맵이 주어졌을 때, 섬의 개수를 계산하라. (연결되어 있는 1의 덩어리 개수를 구하라.)

### 풀이1. DFS로 그래프 탐색

쾨니히스베르크의 다리 문제처럼 반드시 그래프 모양이 아니더라도 그래프형으로 변환해서 풀이할 수 있음을 확인해보는 좋은 문제다. 동서남북이 모두 연결된 그래프로 가정하고 동일한 형태로 처리할 수 있으며, 네 방향 각각 DFS 재귀를 이용해 탐색을 끝마치면 1이 증가하는 형태로 육지의 개수를 파악할 수 있다.

동서남북이 모두 연결된 그래프로 가정하고 동일한 형태로 처리할 수 있으며, 네 방향 각각 DFS 재귀를 이용해 탐색을 끝마치면 1이 증가하는 형태로 육지의 개수를 파악할 수 있다.

DFS 탐색을 하는 dfs() 함수는 동서남북을 모두 탐색하면서 재귀호출한다.

<aside>
💡 중첩 함수: 함수 내에 위치한 또 다른 함수로, 바깥에 위치한 함수들과 달리 부모 함수의 변수를 자유롭게 읽을 수 있다는 장점이 있다.

</aside>

---

## 33 [전화 번호 문자 조합](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

2에서 9까지 숫자가 주어졌을 때 전화 번호로 조합 가능한 모든 문자를 출력하라.

### 풀이1. 모든 조합 탐색

digits는 입력값이며, 각 자릿수에 해당하는 키판 배열 dic을 DFS로 탐색하면 결과가 완성된다. 입력값을 자릿수로 쪼개어 반복하고, 숫자에 해당하는 모든 문자열을 반복하면서 마찬가지로 문자 단위로 재귀 탐색한다.

dfs() 함수는 자릿수가 동일할 때까지 재귀 호출을 반복하다 끝까지 탐색하면 결과를 추가하고 리턴한다.